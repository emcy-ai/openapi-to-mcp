/**
 * Code Generator - Generates MCP server code from tool definitions
 */
/**
 * Generate a complete MCP server from tool definitions
 */
export function generateMcpServer(tools, options, securitySchemes = {}) {
    const files = {};
    files['package.json'] = generatePackageJson(options);
    files['tsconfig.json'] = generateTsConfig();
    files['src/index.ts'] = generateServerEntry(tools, options, securitySchemes);
    files['src/transport.ts'] = generateTransport();
    files['.env.example'] = generateEnvExample(tools, securitySchemes);
    files['README.md'] = generateReadme(options);
    return files;
}
function generatePackageJson(options) {
    const pkg = {
        name: options.name,
        version: options.version || '1.0.0',
        description: `MCP Server generated from OpenAPI spec`,
        type: 'module',
        main: 'build/index.js',
        scripts: {
            build: 'tsc',
            start: 'node build/index.js',
            'start:http': 'node build/index.js --transport=streamable-http',
            dev: 'tsc --watch',
        },
        dependencies: {
            '@modelcontextprotocol/sdk': '^1.10.0',
            axios: '^1.9.0',
            dotenv: '^16.4.5',
            hono: '^4.7.7',
            '@hono/node-server': '^1.14.1',
            ...(options.emcyEnabled ? {
                '@emcy/sdk': options.localSdkPath ? `file:${options.localSdkPath}` : '^0.1.0'
            } : {}),
        },
        devDependencies: {
            '@types/node': '^22.15.2',
            typescript: '^5.8.3',
        },
        engines: {
            node: '>=20.0.0',
        },
    };
    return JSON.stringify(pkg, null, 2);
}
function generateTsConfig() {
    const config = {
        compilerOptions: {
            target: 'ES2022',
            module: 'NodeNext',
            moduleResolution: 'NodeNext',
            lib: ['ES2022'],
            outDir: './build',
            rootDir: './src',
            strict: true,
            esModuleInterop: true,
            skipLibCheck: true,
            forceConsistentCasingInFileNames: true,
            declaration: true,
            sourceMap: true,
        },
        include: ['src/**/*'],
        exclude: ['node_modules', 'build'],
    };
    return JSON.stringify(config, null, 2);
}
function generateServerEntry(tools, options, securitySchemes) {
    const toolDefinitions = tools.map(tool => {
        return `  ["${tool.name}", {
    name: "${tool.name}",
    description: ${JSON.stringify(tool.description)},
    inputSchema: ${JSON.stringify(tool.inputSchema)},
    method: "${tool.httpMethod}",
    pathTemplate: "${tool.pathTemplate}",
    parameters: ${JSON.stringify(tool.parameters)},
    requestBodyContentType: ${tool.requestBodyContentType ? `"${tool.requestBodyContentType}"` : 'undefined'},
    securitySchemes: ${JSON.stringify(tool.securitySchemes)},
  }]`;
    }).join(',\n');
    const emcyImport = options.emcyEnabled
        ? `import { EmcyTelemetry } from '@emcy/sdk';\n`
        : '';
    const emcyInit = options.emcyEnabled
        ? `
// Initialize Emcy telemetry if API key is provided
const emcy = process.env.EMCY_API_KEY
  ? new EmcyTelemetry({
      apiKey: process.env.EMCY_API_KEY,
      endpoint: process.env.EMCY_TELEMETRY_URL,
      mcpServerId: process.env.EMCY_MCP_SERVER_ID,
      debug: process.env.EMCY_DEBUG === 'true',
    })
  : null;

// Set server info for telemetry metadata
if (emcy) {
  emcy.setServerInfo(SERVER_NAME, SERVER_VERSION);
}
`
        : '';
    const emcyTrace = options.emcyEnabled
        ? `
    // Wrap with Emcy telemetry if enabled
    if (emcy) {
      return emcy.trace(toolName, async () => executeRequest(toolDefinition, toolArgs));
    }
`
        : '';
    return `#!/usr/bin/env node
/**
 * MCP Server: ${options.name}
 * Generated by Emcy OpenAPI-to-MCP Generator
 */

import dotenv from 'dotenv';
dotenv.config();

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  type Tool,
  type CallToolResult,
  type CallToolRequest
} from "@modelcontextprotocol/sdk/types.js";
import axios, { type AxiosRequestConfig, type AxiosError } from 'axios';
import { setupStreamableHttpServer } from "./transport.js";
${emcyImport}
// Configuration
export const SERVER_NAME = "${options.name}";
export const SERVER_VERSION = "${options.version || '1.0.0'}";
export const API_BASE_URL = process.env.API_BASE_URL || "${options.baseUrl}";

// Tool definition interface
interface McpToolDefinition {
  name: string;
  description: string;
  inputSchema: Record<string, unknown>;
  method: string;
  pathTemplate: string;
  parameters: { name: string; in: string; required: boolean }[];
  requestBodyContentType?: string;
  securitySchemes: string[];
}

// Security schemes
const securitySchemes: Record<string, unknown> = ${JSON.stringify(securitySchemes, null, 2)};
${emcyInit}
// Tool definitions
const toolDefinitionMap: Map<string, McpToolDefinition> = new Map([
${toolDefinitions}
]);

// Create MCP server
const server = new Server(
  { name: SERVER_NAME, version: SERVER_VERSION },
  { capabilities: { tools: {} } }
);

// List tools handler
server.setRequestHandler(ListToolsRequestSchema, async () => {
  const toolsForClient: Tool[] = Array.from(toolDefinitionMap.values()).map(def => ({
    name: def.name,
    description: def.description,
    inputSchema: def.inputSchema as Tool['inputSchema'],
  }));
  return { tools: toolsForClient };
});

// Call tool handler
server.setRequestHandler(CallToolRequestSchema, async (request: CallToolRequest): Promise<CallToolResult> => {
  const { name: toolName, arguments: toolArgs } = request.params;
  const toolDefinition = toolDefinitionMap.get(toolName);
  
  if (!toolDefinition) {
    return { content: [{ type: "text", text: \`Error: Unknown tool: \${toolName}\` }] };
  }
  
  try {
${emcyTrace}
    return await executeRequest(toolDefinition, toolArgs ?? {});
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return { content: [{ type: "text", text: \`Error: \${message}\` }] };
  }
});

// Execute API request
async function executeRequest(
  def: McpToolDefinition,
  args: Record<string, unknown>
): Promise<CallToolResult> {
  let url = def.pathTemplate;
  const queryParams: Record<string, unknown> = {};
  const headers: Record<string, string> = { 'Accept': 'application/json' };
  
  // Apply path and query parameters
  for (const param of def.parameters) {
    const value = args[param.name];
    if (value !== undefined && value !== null) {
      if (param.in === 'path') {
        url = url.replace(\`{\${param.name}}\`, encodeURIComponent(String(value)));
      } else if (param.in === 'query') {
        queryParams[param.name] = value;
      } else if (param.in === 'header') {
        headers[param.name.toLowerCase()] = String(value);
      }
    }
  }
  
  // Apply security (API key, Bearer token)
  applySecurityHeaders(headers, def.securitySchemes);
  
  // Build request config
  const config: AxiosRequestConfig = {
    method: def.method,
    url: \`\${API_BASE_URL}\${url}\`,
    params: queryParams,
    headers,
  };
  
  // Add request body if present
  if (def.requestBodyContentType && args.requestBody !== undefined) {
    config.data = args.requestBody;
    headers['content-type'] = def.requestBodyContentType;
  }
  
  console.error(\`Executing: \${def.method.toUpperCase()} \${config.url}\`);
  
  const response = await axios(config);
  
  let responseText: string;
  if (typeof response.data === 'object') {
    responseText = JSON.stringify(response.data, null, 2);
  } else {
    responseText = String(response.data ?? '');
  }
  
  return {
    content: [{ type: "text", text: \`Status: \${response.status}\\n\\n\${responseText}\` }]
  };
}

// Apply security headers based on environment variables
function applySecurityHeaders(headers: Record<string, string>, schemeNames: string[]) {
  for (const schemeName of schemeNames) {
    const scheme = securitySchemes[schemeName] as Record<string, unknown> | undefined;
    if (!scheme) continue;
    
    const envKey = schemeName.replace(/[^a-zA-Z0-9]/g, '_').toUpperCase();
    
    if (scheme.type === 'apiKey') {
      const apiKey = process.env[\`API_KEY_\${envKey}\`];
      if (apiKey && scheme.in === 'header' && typeof scheme.name === 'string') {
        headers[scheme.name.toLowerCase()] = apiKey;
      }
    } else if (scheme.type === 'http' && scheme.scheme === 'bearer') {
      const token = process.env[\`BEARER_TOKEN_\${envKey}\`];
      if (token) {
        headers['authorization'] = \`Bearer \${token}\`;
      }
    }
  }
}

// Main
async function main() {
  const args = process.argv.slice(2);
  const useHttp = args.includes('--transport=streamable-http');
  
  if (useHttp) {
    const port = parseInt(process.env.PORT || '3000', 10);
    await setupStreamableHttpServer(server, port);
  } else {
    // Stdio transport for Claude Desktop, etc.
    const { StdioServerTransport } = await import("@modelcontextprotocol/sdk/server/stdio.js");
    const transport = new StdioServerTransport();
    await server.connect(transport);
    console.error(\`\${SERVER_NAME} running on stdio\`);
  }
}

main().catch(console.error);
`;
}
function generateTransport() {
    return `/**
 * Streamable HTTP Transport for MCP
 */

import { Hono } from 'hono';
import { cors } from 'hono/cors';
import { serve } from '@hono/node-server';
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { SERVER_NAME, SERVER_VERSION } from './index.js';

const { WebStandardStreamableHTTPServerTransport } = await import(
  "@modelcontextprotocol/sdk/server/webStandardStreamableHttp.js"
);

const transports: Map<string, InstanceType<typeof WebStandardStreamableHTTPServerTransport>> = new Map();

export async function setupStreamableHttpServer(mcpServer: Server, port = 3000) {
  const app = new Hono();
  
  app.use('*', cors({
    origin: '*',
    allowMethods: ['GET', 'POST', 'DELETE', 'OPTIONS'],
    allowHeaders: ['Content-Type', 'Accept', 'mcp-session-id', 'Last-Event-ID'],
    exposeHeaders: ['mcp-session-id'],
  }));
  
  app.get('/health', (c) => {
    return c.json({ status: 'OK', server: SERVER_NAME, version: SERVER_VERSION });
  });
  
  app.all("/mcp", async (c) => {
    const sessionId = c.req.header('mcp-session-id');
    
    if (sessionId && transports.has(sessionId)) {
      return transports.get(sessionId)!.handleRequest(c.req.raw);
    }
    
    if (!sessionId) {
      const transport = new WebStandardStreamableHTTPServerTransport({
        sessionIdGenerator: () => crypto.randomUUID(),
        onsessioninitialized: (newSessionId: string) => {
          transports.set(newSessionId, transport);
        }
      });
      
      transport.onerror = (err: Error) => console.error('Transport error:', err);
      transport.onclose = () => {
        const sid = transport.sessionId;
        if (sid) transports.delete(sid);
      };
      
      await mcpServer.connect(transport);
      return transport.handleRequest(c.req.raw);
    }
    
    return c.json({ error: 'Session not found' }, 404);
  });
  
  serve({ fetch: app.fetch, port }, (info) => {
    console.error(\`MCP Server running at http://localhost:\${info.port}\`);
    console.error(\`- MCP Endpoint: http://localhost:\${info.port}/mcp\`);
    console.error(\`- Health Check: http://localhost:\${info.port}/health\`);
  });
  
  return app;
}
`;
}
function generateEnvExample(tools, securitySchemes) {
    const lines = [
        '# API Configuration',
        'API_BASE_URL=http://localhost:5001',
        '',
        '# Emcy Telemetry (optional)',
        '# Set these to enable telemetry to Emcy platform',
        '# EMCY_API_KEY=your-api-key-from-emcy-dashboard',
        '# EMCY_TELEMETRY_URL=http://localhost:5140/api/v1/telemetry',
        '# EMCY_MCP_SERVER_ID=mcp_xxxxxxxxxxxx',
        '# EMCY_DEBUG=false',
        '',
        '# Server Port (for HTTP transport)',
        'PORT=3000',
    ];
    // Collect unique security schemes used by tools
    const usedSchemes = new Set();
    for (const tool of tools) {
        for (const scheme of tool.securitySchemes) {
            usedSchemes.add(scheme);
        }
    }
    if (usedSchemes.size > 0) {
        lines.push('', '# Security Credentials');
        for (const schemeName of usedSchemes) {
            const scheme = securitySchemes[schemeName];
            const envKey = schemeName.replace(/[^a-zA-Z0-9]/g, '_').toUpperCase();
            if (scheme?.type === 'apiKey') {
                lines.push(`API_KEY_${envKey}=your-api-key`);
            }
            else if (scheme?.type === 'http' && scheme.scheme === 'bearer') {
                lines.push(`BEARER_TOKEN_${envKey}=your-bearer-token`);
            }
            else if (scheme?.type === 'oauth2') {
                lines.push(`OAUTH_CLIENT_ID_${envKey}=your-client-id`);
                lines.push(`OAUTH_CLIENT_SECRET_${envKey}=your-client-secret`);
            }
        }
    }
    return lines.join('\n');
}
function generateReadme(options) {
    return `# ${options.name}

MCP Server generated from OpenAPI specification.

## Quick Start

\`\`\`bash
# Install dependencies
npm install

# Build
npm run build

# Run with HTTP transport (recommended for Cursor)
npm run start:http

# Or run with stdio transport (for Claude Desktop)
npm start
\`\`\`

## Configuration

Copy \`.env.example\` to \`.env\` and configure:

- \`API_BASE_URL\`: Base URL of the API (default: ${options.baseUrl})
- \`PORT\`: Server port for HTTP transport (default: 3000)
- Security credentials as needed

## Using with Cursor

Add to your \`~/.cursor/mcp.json\`:

\`\`\`json
{
  "mcpServers": {
    "${options.name}": {
      "url": "http://localhost:3000/mcp"
    }
  }
}
\`\`\`

Then restart Cursor.

## Using with Claude Desktop

Add to your Claude Desktop config:

\`\`\`json
{
  "mcpServers": {
    "${options.name}": {
      "command": "node",
      "args": ["${process.cwd()}/build/index.js"]
    }
  }
}
\`\`\`
`;
}
//# sourceMappingURL=generator.js.map